# -*- coding: utf-8 -*-
"""HW3 Perception and intelligence.ipynb

Automatically generated by Colaboratory.

"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import cv2
from google.colab.patches import cv2_imshow
import matplotlib.pyplot as plt
# %matplotlib inline

# Problem 1-1) "RGB to gray conversion"

#Function to convert rgb to gray image

def rgb2gray(image):
    red_channel = image[:,:,0]
    green_channel = image[:,:,1]
    blue_channel = image[:,:,2]
    rgb_weights = [0.2989, 0.5870, 0.1140] #RGB weights for grayscale conversion
    gray_image = red_channel * rgb_weights[0] + green_channel * rgb_weights[1] + blue_channel * rgb_weights[2]
    return gray_image

#Checking the function output using OpenCV

rgb_image = cv2.imread("Lenna.jpg")
print(rgb_image.shape)
gray_image = rgb2gray(np.asarray(rgb_image))
cv2_imshow(np.array(gray_image))

# Problem 1-2) "Downsampling from 256*256 to 64*64"

#Function to downsample the gray image

def downsampling(image, height, width):
  image_height = len(image)     # number of rows 
  image_width = len(image[0])   # number of columns 
  return [[ image[int(image_height * h / height)][int(image_width * w / width)]  
             for w in range(width)] for h in range(height)]

# Checking the function output using OpenCV

new_image = downsampling(gray_image, 64, 64)
new_image = np.asarray(new_image)
print(new_image.shape)
cv2_imshow(np.array(new_image))

# Problem 1-3) "Convolution for edge detection"

# Function to apply convolution to the image.

def convolve2D(image, kernel, padding=0, strides=1):
    # Cross Correlation
    kernel = np.flipud(np.fliplr(kernel))

    # Gather Shapes of Kernel + Image + Padding
    xKernShape = kernel.shape[0]
    yKernShape = kernel.shape[1]
    xImgShape = image.shape[0]
    yImgShape = image.shape[0]

    # Shape of Output Convolution
    xOutput = int(((xImgShape - xKernShape + 2 * padding) / strides) + 1)
    yOutput = int(((yImgShape - yKernShape + 2 * padding) / strides) + 1)
    output = np.zeros((xOutput, yOutput))

    # Apply Equal Padding to All Sides
    if padding != 0:
        imagePadded = np.zeros((image.shape[0] + padding*2, image.shape[1] + padding*2))
        imagePadded[int(padding):int(-1 * padding), int(padding):int(-1 * padding)] = image
    else:
        imagePadded = image

    # Iterate through image
    for y in range(image.shape[1]):
        # Exit Convolution
        if y > image.shape[1] - yKernShape:
            break
        # Only Convolve if y has gone down by the specified Strides
        if y % strides == 0:
            for x in range(image.shape[0]):
                # Go to next row once kernel is out of bounds
                if x > image.shape[0] - xKernShape:
                    break
                try:
                    # Only Convolve if x has moved by the specified Strides
                    if x % strides == 0:
                        output[x, y] = (kernel * imagePadded[x: x + xKernShape, y: y + yKernShape]).sum()
                except:
                    break

    return output

# Checking the function output using OpenCV    

kernel = np.array([[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]])

conv2d = convolve2D(gray_image,kernel, padding=2)
cv2_imshow(np.array(conv2d))

"""# New Section"""

# Problem 2-1) "Histogram analysis"

# Function to perform histogram analysis
def histogram(image):
    rows = len(image)
    columns = len(image[0])
    counts = np.zeros(len(image))
    for col in range(columns):
      for row in range(rows):
          grayLevel = int(image[row, col])           
          counts[grayLevel] = counts[grayLevel] + 1      
    return counts      

# Plotting the histogram.
counts = histogram(gray_image)
intensity_levels = np.arange(256)
plt.bar(intensity_levels, counts, width=0.8)
plt.xlabel('Intensity Levels')
plt.ylabel('Pixel Count')
plt.title('Histogram analysis of Lenna gray image')
plt.show()

"""# New Section"""

# Problem 2-2) "Cumulative histogram"

# Function to calculate the cumulative histogram

def cumulative_histogram(histogram_frequency):
    cumulative = []
    length = len(histogram_frequency)
    for values in range(length):
        cumulative.append(sum(histogram_frequency[0:values:1]))
    return cumulative

# Plotting the Cumulative histogram.
cumulative_counts = cumulative_histogram(counts)
intensity_levels = np.arange(256)
plt.bar(intensity_levels, cumulative_counts, width=0.8)
plt.xlabel('Cumulative Intensity Levels')
plt.ylabel('Pixel Count')
plt.title('Cumulative histogram analysis of Lenna gray image')
plt.show()

# Problem 2-3) "Histogram Equalization"

# Function to calculate histogram equalization

def histogram_equalization(cumulative_sum):
    # Formula to perform the normalization s_k = sum(n_j / N) where j = 0 to k
    numerator = (np.array(cumulative_sum) - min(np.array(cumulative_sum))) * 255
    denominator = max(cumulative_sum) - min(cumulative_sum)

    #normalization
    cumulative_norm = numerator/denominator
    cumulative_norm = cumulative_norm.astype('uint8')

    # Using the normalized cumulative values to modify/map the intensity 
    # values in the original image 
    modified_image = cumulative_norm[np.array(gray_image, dtype=int)]

    return cumulative_norm, modified_image

# Checking the function
cum_norm, modified_image = histogram_equalization(cumulative_counts)
plt.bar(intensity_levels, cum_norm, width=0.8)
plt.xlabel('Normalized Intensity Levels')
plt.ylabel('Pixel Count')
plt.title('Cumulative normalized histogram analysis of Lenna gray image')
plt.show()

# Comparing the original image and the modified 
# image. Also their histogram distribution before
# and after histogram equalization

# plotting original image
fig = plt.figure()
fig.add_subplot(2,2,1)
plt.imshow(gray_image, cmap ='gray')
plt.title('Original gray image')

# plotting equalized image
fig.add_subplot(2,2,2)
plt.imshow(modified_image, cmap ='gray')
plt.title('Histogram equalized image')

# plotting histogram analysis of equalized image
counts_equalized = histogram(modified_image)
intensity_levels = np.arange(256)
plt.figure()
plt.bar(intensity_levels, counts_equalized, width=0.8)
plt.xlabel('Intensity Levels')
plt.ylabel('Pixel Count')
plt.title('Histogram analysis of Equalized Lenna gray image')
plt.show()

# Problem 3-1) "Histogram analysis and binary image conversion"

# Visualizing the parkinglot image
parkinglot_image = cv2.imread("ParkingLot.jpg")
plt.imshow(parkinglot_image, cmap='gray')
plt.show()

# Converting the parkinglot image to gray image 
parkinglot_gray_image = cv2.cvtColor(parkinglot_image, cv2.COLOR_BGR2GRAY)
cv2_imshow(parkinglot_gray_image)

# Histogram analysis of the parkinglot gray image
hist_parkinglot = histogram(parkinglot_gray_image)
intensity_levels = np.arange(len(hist_parkinglot))
plt.bar(intensity_levels, hist_parkinglot, width=0.8)
plt.xlabel('Intensity Levels')
plt.ylabel('Pixel Count')
plt.title('Histogram analysis of Parkinglot gray image')
plt.show()

# Thershold to convert the gray image to binary image
threshold = 225  #our goal is to detect the lanes, so I am using a higher threshold
thres, binary_image = cv2.threshold(parkinglot_gray_image, threshold ,255, cv2.THRESH_BINARY)
print(thres)
plt.imshow(binary_image, cmap="gray")

# Problem 3-2) "Hough Transform to find the lane lines"

threshold_for_line = 70
minLineLength = 10
maxLineGap = 40
lines = cv2.HoughLinesP(binary_image, 1, np.pi/180, threshold_for_line, minLineLength = minLineLength, maxLineGap=maxLineGap)

line_points = []
for line in lines:
    x1,y1,x2,y2 = line[0]
    line_points.append(line[0])
    cv2.line(parkinglot_image, pt1=(x1,y1), pt2=(x2,y2), color=(0,255,0), thickness=2 )

plt.imshow(parkinglot_image)  
import operator
sorted(line_points, key=operator.itemgetter(0,1))

# Visualizing the image in polar transform
radius = np.sqrt(((parkinglot_image.shape[0]/2)**2) + ((parkinglot_image.shape[1]/2)**2))
center = (parkinglot_image.shape[0]/2, parkinglot_image.shape[1]/2)

polar_transform = cv2.linearPolar(parkinglot_image, center, radius, cv2.WARP_POLAR_LINEAR)
polar_image = polar_transform.astype(np.uint8)

cv2_imshow(polar_image)
